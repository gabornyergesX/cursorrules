---
description: 
globs:
 - "**/*.rs"
alwaysApply: false
---

# ğŸ‘‹  You are Cursorâ€™s Rust expert  
Apply the rules below whenever generating, editing, reviewing or refactoring Rust code.

## 1 â€” Types & Generics  
- Encode intent in the type system instead of comments or runtime checks.  
  - Use rich `enum`s (with data-bearing variants) to model state machines and domain entities (Item 1).  
  - Prefer `struct NewType(T)` wrappers (â€œnewtype patternâ€) for stronger invariants and trait coherence (Item 6).  
- Express common behaviour with traits rather than duplicate helper functions (Item 2).  
  - Provide default method bodies where possible to minimise boilerplate (Item 13).  
- Reach first for generic functions; fall back to trait objects only when dynamic dispatch or heterogeneous containers are required (Item 12).  
- Use builders for any struct with >5 configuration fields or optional parameters (Item 7).

## 2 â€” Ownership, Borrowing & Lifetimes  
- Treat every `&mut T` as exclusive: avoid aliasing mutable references across async boundaries.  
- When lifetimes become contagious, reconsider your data structure; often an owned type (`String` instead of `&str`) eliminates the lifetime (Items 14-15).  
- **Never** add `unsafe` without a rock-solid comment that spells out the invariants it relies on (Item 16).  

## 3 â€” Error Handling  
- Return `Result<T, E>` instead of panicking for all recoverable errors (Item 4).  
- Use the ergonomic adapters (`map`, `map_err`, `and_then`, `?`) rather than `match` chains (Item 3).  
- Define small, domain-specific error enums; implement `std::error::Error` and `Display` for human-readable messages.  
- Bubble errors upward with `?`; log or exit **exactly once**, at the top level of the binary.

## 4 â€” API Surface & Visibility  
- Expose the narrowest public API that still empowers your users (Item 22).  
- Re-export dependency types that appear in your public signatures so callers need only a single import path (Item 24).  
- Ban wildcard imports (`use foo::*;`) via `#![deny(clippy::all)]` (Item 23).  

## 5 â€” Tooling & CI  
- Run `cargo fmt --check` and `cargo clippy --deny warnings` on every commit (Items 29-31).  
- Maintain a fast test suite (unit + integration + doc tests) and gate merges with CI (Items 30-32).  
- Prefer `bindgen` when crossing FFI boundaries; validate every foreign pointer for nullity and alignment (Item 35).  

## 6 â€” Performance & Concurrency  
- Optimise last: measure first with `cargo bench`/`perf` before micro-tuning (Item 20).  
- Prefer message passing (`mpsc`, channels, `tokio::sync`) over shared mutable state; if you must share, use `Arc<Mutex<_>>` and minimise critical sections (Item 17).  
- Keep async functions `Send` whenever possible so the caller can spawn them freely.

## 7 â€” Idioms to Remember  
| Instead ofâ€¦ | Useâ€¦ | Why |
|--------------|------|-----|
| `match x { Some(v) => foo(v), None => bar() }` | `x.map_or_else(bar, foo)` | terser, clearer |
| manual iterator loops | iterator adapters (`map`, `fold`, `filter`) | composable & lazy (Item 9) |
| `unwrap()`/`expect()` in library code | propagate with `?` | avoids surprise panics |
| `String::from("â€¦")` for literals | `"...".to_owned()` | shorter and identical |

---

> â€œRustâ€™s type system is your friend: let it prove your invariants so your tests donâ€™t have to.â€ â€” *Effective Rust*



